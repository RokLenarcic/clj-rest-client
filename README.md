# REST Client

A Clojure library which converts a REST specification into functions that emit `clj-http` request maps.

Very light-weight. 

**[Change Log](CHANGELOG.md)**

## Quick start

This library requires clojure 1.9.0 or higher.

Add to dependencies:

```clojure
[clj-rest-client "1.0.0"]
```

In your namespace add dependency:

```clojure
(ns example.core
  (:require [clj-rest-client.core :refer [defrest]
            [clj-http.client :as client]]))
```

Define a rest interface:

```clojure
(defrest {"http://example.com" {"person" {GET (get-person-by-id [id pos-int?])}}})
```

This defines a function named **`get-person-by-id`** that you can now call and it will return a `clj-http` compatible map.

You can then run the request by using `clj-http`:

```clojure
(client/request (get-person-by-id 3))
```

The function is spec instrumented, and will raise an error if parameters aren't valid by spec.

You can make the http call immediate by adding http request executing function as a client function to API definition:

```clojure
(defrest {"http://example.com" {"person" {GET (get-person-by-id [id pos-int?])}}} :client client/request)

(get-person-by-id 3)
```

**All data structure merges in this framework are deep merges using `meta-merge` library. See https://github.com/weavejester/meta-merge for specifics.**

## Usage

A series of tutorials using GitHub v3 API as basis:

#### [Tutorial 1 - First Request](doc/t1/t1.md)
#### [Tutorial 2 - Parameter types](doc/t2/t2.md)
#### [Tutorial 3 - Client object](doc/t3/t3.md)
#### [Tutorial 4 - Parameter Specs](doc/t4/t4.md)
#### [Tutorial 5 - Varargs parameters](doc/t5/t5.md)
#### [Tutorial 6 - Splitting definition](doc/t6/t6.md)
#### [Tutorial 7 - A different way to describe API](doc/t7/t7.md)
#### [Tutorial 8 - Fun with paging](doc/t7/t7.md)

A description of features, options and solutions for common use-cases.

### Definition format

#### Paths and overall structure

Definition is a nested map where keys are string paths or symbol, keyword HTTP methods.

```clojure
{"path"
  {"subpath" {DELETE ...}
   GET ...
   :post ...}}
``` 

This nested structure defines endpoints for GET and POST methods at "/path". Path parts should not start or end with `/`.
It also continues nesting and defines endpoint for "/path/subpath" for DELETE method.

Values for path parts are another path map, values for methods are endpoint function definitions 


Symbol or keyword keys define signature for a HTTP method for this subpath. E.g.

```clojure
(defrest {"http://example.com" 
           {"person" 
             {"{id}" 
               {GET (get-person-by-id [id pos-int? detail-level pos-int?] {:as :bytes})}}}})
```

Here the GET symbol key is followed by an endpoint definition, which defines a function for GET method for `http://example.com/person` subpath.

Method can be specified equally as `GET` or `get` or `:get`.

The string keys in the nested definition map are there to denote subpaths. They shouldn't start or end with `/`.

**In this particular example the root string key also defines protocol, server, port.**

**This is in no way required. You can define a REST with relative paths only.**

It will be demonstated later how to approach using definitions without predefined host.

#### Endpoint definition

```clojure
{GET (get-example any? [id pos-int? time inst?] {:as :bytes})}
```

The endpoint definition is a list or vector (in this example a list), which contains the following:

- a symbol, name of function to be declared
- an optional spec that is applied to conformed parameter list
- an argument vector, must contain alternating parameter names and parameter specs. The vector may contain symbol `&`, all argument
specs following the symbol are added as kw-varargs on the generated function with provided specs wrapped in `nilable`.

- an optional non-vector expression that evaluates to a map, defaults to `{}`, contains additional properties for returned request map, 
it can use parameters in definition

In this example, the spec applied to parameter list `[id time]` will be `(s/& (s/cat :id pos-int? :time inst?) any?)`.

Due to optionals the following definition is also legal:

```clojure
{GET (get-all [])}
``` 

#### Default method

If the endpoint is the only one at a subpath you can skip specifying the method and it gaing the default method:

```clojure
(get-all [])
```

The method given to such endpoint definition is set by `:default-method` `defrest` parameter, defaulting to `:get`.

### defrest options

The macro support options as varargs key-values.

Here's the options with defaults

```clojure
(defrest {} :param-transform identity :json-responses true :jsonify-bodies :smart :client identity)
```

#### client

This option specifies function that is invoked with clj-http maps generated by api functions. Defaults to identity.
This is a good place to put your http client function if you want requests to be executed immediately.

There are benefits to separating request generation and request execution, thus the default being identity function.

#### default-method 

Sets the default method for endpoints with no method specified, defaults to `:get`

#### name-transform

This option specifies function that is used to transform function's symbol name. Defaults to identity.

This is useful when having multiple `defrest` calls with same API in a single namespace.

#### param-transform

This option specifies function that is used to transform query parameter names: parameter (symbol) -> query parameter name (string).

This is useful to transform clojure's kebab-case symbol names to camel case param names.

#### val-transform

This option specifies a function that is applied to all arguments after argument spec and conform and before being embedded into
request map. It's a function of two arguments: param name symbol and param value, returns new param value. 

Default implementation replaces keyword params with their name string. It's available (for delegating purposes) as `default-val-transform` in core namespace.

#### json-responses

If true then all requests specify `{:as :json}` and all responses are expected to be json responses. Default true.

#### jsonify-bodies

Set to `:always`, `:smart`, `:never`. Body params will be ran through serializer if set to `:always`. 
Option `:smart` will not run string bodies through JSON serializer. Defaults to :smart.

#### defaults

Defaults option should resolve to a map. This map is included in every request map as a baseline. Defaults to `{}`


## License

Copyright © 2018 Rok Lenarčič

Distributed under the Eclipse Public License either version 1.0 or (at
your option) any later version.
