# Tutorial 4 - Reshaping Parameters

Parameters have schemas. This has two effects:

- validation is performed
- parameters are encoded by the specified Malli transformer(default none), note that JSON conversion
is done on top of that if needed

## Parameter schema

Using parameter transformation is one way you can create interfaces where complex types are 
serialized in a specific way before going over the wire. 

### **[CODE: Current state](t4.clj)**

At this point lets add an endpoint that lists all of the repository's issues:

```clojure
"issues" {GET (list-repo-issues [])
.....

```

This endpoint has a lot of parameters, but we are interesed in the one named `since`,
which is an ISO formatted timestamp string. 

We don't want to use `string` as the parameter type but we'd rather use 
something like `#inst` instead.

Malli supports encoding `java.util.Date` objects (`#inst`) to ISO timestamps out of the box in their
`json-transformer` and `string-transformer`, but we don't want to use that.

The reason why we want to use another transformer is because built in transformers do too much for our purposes,
because this library runs JSON encode over any `json` request bodies (unless disabled), 
so a `string-transformer` will change any integers into strings and then JSON encoder will encode them as strings,
which the target service might regard as wrong.

Instead we will create out own transformer at the top of the file,
after requiring `[malli.transform :as mt]`:

```clojure
(def xf
  (mt/transformer
    {:name :rest-client
     :encoders (select-keys mt/+string-encoders+ ['inst?])
     :decoders (select-keys mt/+string-decoders+ ['inst?])}))
```

We gave it a nice name, which is useful if you want to declare special encode/decode functions
directly on a schema. We simply filtered the existing encoders to string.

We add it to `defrest`:

```clojure
(defrest {.....}
  :transformer xf)
```

Now we just add the parameter and the schema:


```clojure
"issues" {GET (list-repo-issues [since [:maybe inst?]])
.....

```

Calling the function:

```clojure
(list-repo-issues "ansible" "ansible" #inst "2011")
=>
{:clj-rest-client.core/args ["ansible" "ansible" "2011-01-01T00:00:00.000Z"],
 :clj-rest-client.core/name t4.t4-end/list-repo-issues,
 :request-method :get,
 :url "repos/ansible/ansible/issues",
 :as :json,
 :query-params {"since" "2011-01-01T00:00:00.000Z"}}
```

As you can see the query parameter is a conformed value. You can bring in more transformers from other libraries to
handle Java 8 Time objects for instance.

## Full arg list schema

There's also an overall function schema you can add by adding a schema between the
function symbol and parameter vector.

This schema is validated on a map which contains all the parameters, so for the above
function it would look like this:

```clojure
{:owner "ansible", :repo "ansible", :since "2011-01-01T00:00:00.000Z"}
```

Let's add `state` parameter to endpoint.

```clojure
"issues" {GET (list-repo-issues [state [:maybe string?] since [:maybe inst?]])
.....

```

Now let's suppose that we wanted to enforce that if `state` filter of issues is `"all"` 
then the `since` parameter is mandatory.

Let's write a schema and add a custom error message, at the top of the file:

```clojure
(def filtered-function [:fn {:error/message "filters that target state \"all\" must limit by \"since\""}
                        '(fn [{:keys [since state]}] (or (not= state "all") since))])
```

Now simply add it to endpoint definition:

```clojure
"issues" {GET (list-repo-issues filtered-function [state [:maybe string?] since [:maybe inst?]])
.....

```

You will notice that you cannot leave the parameter `since` at `nil` if `state` parameter is `all`,
but otherwise you can.

### **[CODE: End state](t4-end.clj)**
